``` Go
package main

import "fmt"

type Rectangle struct {
    w float64
    l float64
}

// Method with a value receiver
func (r Rectangle) Area() float64 {
    return r.w * r.l
}

func (r *Rectangle) Scale(factor float64) {
    r.w *= factor
    r.l *= factor
}

func main() {
    r := Rectangle{w: 10, l: 5} // <-- هنا الإنشاء المباشر

    area := r.Area()
    fmt.Println("area :", area)
    r.Scale(2)

    fmt.Println("Scale w :", r.w, "Scale l", r.l)
}
```

السطر المهم هنا هو:


```
Go
 r := Rectangle{w: 10, l: 5}
```

هذه هي طريقة **الإنشاء المباشر** لكائن من نوع `Rectangle`. أنت تقوم بتحديد قيم الحقول (`w` و `l`) مباشرة عند إنشاء الكائن.


**متى تكون هذه الطريقة جيدة؟** 🤔

- **البساطة والوضوح:** عندما يكون الـ `struct` بسيطًا ولا يتطلب أي منطق خاص عند إنشائه.
- **الأمثلة الصغيرة أو الاختبارات:** تكون سريعة ومناسبة للأكواد التجريبية أو الأمثلة التعليمية.
- **عندما تكون القيم الافتراضية للغة مناسبة:** إذا لم يتم تحديد قيمة لحقل ما، ستأخذ القيمة الافتراضية لنوعها (مثلاً، 0 للأرقام، سلسلة فارغة للنصوص، `false` للقيم المنطقية).

**لكن، هناك بعض العيوب المحتملة:** 😟

- **قد تنسى تهيئة بعض الحقول:** إذا كان الـ `struct` يحتوي على العديد من الحقول، قد يكون من السهل نسيان تحديد قيمة لأحدها، مما قد يؤدي إلى سلوك غير متوقع إذا كانت القيمة الافتراضية غير مناسبة.
- **لا يوجد مكان لإضافة منطق التحقق (Validation):** ماذا لو أردت التأكد من أن العرض (`w`) والطول (`l`) للمستطيل يجب أن يكونا دائمًا أرقامًا موجبة؟ لا يمكنك فرض ذلك بسهولة باستخدام الإنشاء المباشر.
- **أقل مرونة للتغييرات المستقبلية:** إذا تغيرت طريقة إنشاء الكائن (مثلاً، إضافة حقل جديد يتطلب حسابًا معينًا)، ستحتاج إلى تعديل كل مكان يتم فيه إنشاء الكائن مباشرة






رائع جدًا أنك بدأت ترى الفروقات! وحماسك للدوال البانية (Constructor Functions) في محله تمامًا، فهي غالبًا ما تكون الخيار الأقوى والأكثر مرونة، خاصة في المشاريع الكبيرة. 👍

هيا بنا ننتقل إلى النقطة التالية التي تتوافق مع تفضيلك:

---

## 3. الطريقة الثانية: استخدام دالة مُنشِئة (Constructor Function)

في الكود الثاني الذي قدمته:




```Go
package main

import "fmt"

type Rectangle struct {
    w float64
    l float64
}

// هذه هي الدالة المُنشِئة
func newRectangle(w float64, l float64) Rectangle {
    return Rectangle{w: w, l: l}
}

// Method with a value receiver
func (r Rectangle) Area() float64 {
    return r.w * r.l
}

func (r *Rectangle) Scale(factor float64) {
    r.w *= factor
    r.l *= factor
}

func main() {
    r := newRectangle(10, 5) // <-- هنا استخدام الدالة المُنشِئة

    area := r.Area()
    fmt.Println("area :", area)
    r.Scale(2)

    fmt.Println("Scale w :", r.w, "Scale l", r.l)
}
```

هنا، قمت بتعريف دالة خاصة اسمها `newRectangle`. هذه الدالة هي المسؤولة عن إنشاء وإرجاع كائن جديد من نوع `Rectangle`. في Go، من المتعارف عليه تسمية هذه الدوال بـ `New` متبوعًا باسم الـ `struct` (مثلاً `NewRectangle` أو `newRectangle`).

**لماذا هذه الطريقة ممتازة جدًا (كما أشرت أنت!)؟** 😍

1. **التغليف (Encapsulation) والتحكم:**
    - **إخفاء تفاصيل الإنشاء:** المستخدم للدالة `newRectangle` لا يحتاج لمعرفة كيف يتم إنشاء الكائن بالضبط من الداخل. هو فقط يوفر القيم المطلوبة.
    - **إضافة منطق التحقق (Validation):** هذا هو المكان المثالي لإضافة شروط. مثلاً، يمكنك التأكد من أن `w` و `l` أكبر من الصفر قبل إنشاء المستطيل:
        
        
        
        ```Go
        func newRectangle(w float64, l float64) (*Rectangle, error) { // نرجع مؤشر وخطأ محتمل
            if w <= 0 || l <= 0 {
                return nil, fmt.Errorf("العرض والطول يجب أن يكونا أكبر من صفر")
            }
            return &Rectangle{w: w, l: l}, nil
        }
        ```
        
        لاحظ كيف أضفنا إمكانية إرجاع خطأ إذا كانت المدخلات غير صالحة.
2. **القيم الافتراضية الذكية:** يمكنك تعيين قيم افتراضية معقدة أو محسوبة داخل الدالة المُنشِئة.
3. **سهولة الصيانة والتعديل:** إذا احتجت لتغيير طريقة إنشاء الكائنات (مثلاً، إضافة حقل جديد يتطلب إعدادًا خاصًا، أو تغيير منطق التحقق)، ستقوم بتعديل الدالة المُنشِئة في مكان واحد فقط، وكل الأماكن التي تستخدمها ستستفيد من التحديث تلقائيًا. هذا يقلل من الأخطاء ويوفر الوقت.
4. **تحسين قابلية القراءة:** `user := NewUser("Ahmed", "ahmed@example.com")` قد تكون أوضح من `user := User{Name: "Ahmed", Email: "ahmed@example.com", IsActive: true, CreatedAt: time.Now()}` خصوصًا إذا كانت هناك قيم افتراضية كثيرة أو منطق معين لبعض الحقول.
5. **إرجاع مؤشر (Pointer) أو قيمة (Value):** الدالة المُنشِئة تعطيك التحكم في ما إذا كنت تريد إرجاع الكائن نفسه (value) أو مؤشر إليه (`*Rectangle`). إرجاع مؤشر غالبًا ما يكون أفضل للكائنات الكبيرة أو عندما تحتاج الدوال الأخرى لتعديل الكائن الأصلي (كما في دالة `Scale` عندك).

هل هناك عيوب؟ 🤔

ربما العيب الوحيد هو أنها تتطلب كتابة دالة إضافية. لكن هذا "العيب" يتضاءل جدًا أمام الفوائد الكبيرة التي تقدمها، خاصة مع نمو البرنامج وتعقيده.

أليس رائعًا كيف تمنحك الدوال المُنشِئة كل هذه القوة والتحكم؟

هل لديك أي أسئلة حول هذه النقطة، أو هل ترغب في تجربة تعديل دالة `newRectangle` لإضافة نوع من التحقق مثلاً كنشاط تطبيقي؟ 😊