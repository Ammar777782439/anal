
### **التصور العام للتطبيق (Application Concept)**


- [[Registration لتسجيل جهاز جديد في المنصة]].
- [[Firewall لحماية الـ API الخاص بنا من الهجمات]]
- [[Scan للسماح للمستخدم بطلب فحص أمني لجهازه عن بعد]]
- **FindMe**: للسماح للمستخدم بتحديد موقع جهازه المفقود.


 **يستقبل** توكن جاهزاً تم إنشاؤه من قبل نظام آخر، (ومهمتي هي فقط التحقق) من هذا التوكن واستخدام البيانات التي بداخله لإنشاء حساب.

هذا السيناريو شائع  مثل:

- **التسجيل عبر خدمات خارجية (Social Login):** مثل عندما تضغط على "تسجيل الدخول باستخدام Google". جوجل تعطيك توكن، وأنت ترسله إلى السيرفر الخاص بالتطبيق الذي تريد التسجيل فيه.
- **التكامل بين الأنظمة (Microservices):** نظام (أ) يريد تسجيل مستخدم في نظام (ب). فيقوم نظام (أ) بإنشاء توكن بمعلومات المستخدم وإرساله إلى نظام (ب).
- 
---

### **خطة التسجيل المباشر باستخدام توكن جاهز (JWT)**

**الهدف:** أعمل API endpoint يستقبل توكن (JWT) من نظام ثاني، ويتأكد إنه سليم ومافيش فيه تلاعب، وبعدين أقرأ منه بيانات المستخدم زي الاسم والإيميل، وأستخدم هذي البيانات علشان أضيف المستخدم في قاعدة البيانات.

**تشبيه بسيط يوضح الفكرة:**

تخيل إنك واقف حارس على باب حفلة خاصة (يعني منصتك)، وإنت مش المسؤول عن إصدار بطايق الدعوة. الناس (المستخدمين) بيجوا ومعهم بطايق دعوة جاهزة (JWT tokens)، طُبعت من قبل منظم الحفلة (يعني نظام خارجي موثوق).

**وإنت كحارس أمن (يعني السيرفر حقك)، عليك تسوي ثلاث حاجات:**

1. **تفحص البطاقة:** تشوف إذا الدعوة سليمة أو مزورة (يعني تتحقق من توقيع التوكن).
    
2. **تقرأ اسم الضيف:** تطلع البيانات من التوكن، مثل الاسم، الإيميل، معرف المستخدم... إلخ.
    
3. **تسجله ضمن الحضور:** تحفظ بياناته في قاعدة البيانات،او (ارجعه ك استجابه) ؟ نعم او لا , وإذا هو مسجّل من قبل، ممكن تحدث بياناته أو تتجاهله حسب النظام.
سوالي : هل الخدمه الخارجيه سوف تستخدم مفتاح خارجي مشترك بيننا  (مثلاً: `our_shared_super_secret`).
---
### **خطة العمل – تسجيل باستخدام توكن جاهز**

**الأطراف اللي داخلة في الموضوع:**

- **النظام الخارجي (اللي يصدر التوكن):** هو "منظم الحفلة". ممكن يكون سيرفر Google أو أي نظام ثاني من داخل الشركة. **هو اللي يعرف المفتاح السري ويستخدمه لتوقيع التوكن**. (للاجابه علي سوالي السابق)
    
- **المستخدم/العميل:** الشخص أو الجهاز اللي معاه التوكن ويريد يسجل. **هو مجرد حامل للتوكن**.
    
- **السيرفر حقنا (تطبيق Go):** هذا هو النظام اللي نستقبل فيه التوكن. **لازم نعرف نفس المفتاح السري** (الي كان سوالي يتعمد عليه اذ نعم نوافق علي الخطه ) علشان نتحقق من التوقيع.
    

---

### 🟩 **الخطوة الأولى: إصدار التوكن (خارج نظامنا)**

1. النظام الخارجي يقرر إنه يرسل مستخدم يسجل في نظامنا. مثلاً:
    
    - الاسم: "عمار راجح"
        
    - الإيميل: `ammarragha.m@example.com`
        
    - الدور: "مستخدم"
        
2. يقوم بإنشاء JWT فيه البيانات ذي، ويوقعه بالمفتاح السري المشترك بيننا، مثلاً: `our_shared_super_secret`.
    
3. يعطي التوكن هذا للمستخدم/العميل.
    

---

### 🟦 **الخطوة الثانية: المستخدم يجي يسجل عندنا**

1. المستخدم يرسل لنا طلب على الرابط `POST /api/v1/register`.
    
2. يحط التوكن في الهيدر داخل الطلب، كذا:
    
    makefile
    
    
    
    `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`
    

---

### 🟥 **الخطوة الثالثة: التحقق من التوكن وسحب البيانات**

1. السيرفر حقنا يستقبل الطلب.
    
2. يقرأ التوكن من هيدر `Authorization`.
    
3. نبدأ نتحقق من التوكن باستخدام مكتبة JWT في Go:
    
    - **أولاً: التوقيع (Signature Verification):** هل فعلاً التوكن موقَّع بنفس المفتاح السري `our_shared_super_secret`؟ هذه أهم خطوة. لو التوقيع مش صحيح أو التوكن جاي من مصدر مش موثوق → نرفض الطلب على طول بـ `401 Unauthorized`.
        
    - **ثانياً: الصلاحية (Expiration):** إذا التوكن فيه وقت انتهاء (`exp`)، نتأكد إنه ما انتهى.
        
4. لو التوكن طلع سليم، نعتبره موثوق.
    
5. نقرأ البيانات اللي فيه (Payload)، مثلاً:
    
    - الاسم: "عمارراجح"
        
    - الإيميل: `ammarragha.m@example.com`
        
    - الدور: "مستخدم"
        

---

### 🟨 **الخطوة الرابعة: نسجّل المستخدم في قاعدة البيانات**

1. بعد ما عرفنا بياناته من التوكن، نسوي التالي:
    
    - نبحث: هل المستخدم هذا (بإيميله) موجود عندنا؟
        
    - لو موجود: نقول له إنه مسجّل من قبل.
        
    - لو مش موجود: نضيفه في جدول `users`، مثلاً:
        
        sql
        
        
        
        `INSERT INTO users (name, email, role) VALUES ('علي محمد', 'ali.m@example.com', 'مستخدم');`
        

---

### 🟪 **الخطوة الخامسة: نرد على المستخدم**

1. بعد ما نكمل العملية بنجاح:
    
    - نرجّع له حالة `201 Created`
        
    - نرسله رد فيه رسالة نجاح، مثلاً:
        
        json
        
        
        
        `{"message": "المستخدم 'علي محمد' تم تسجيله بنجاح"}`
        

---



### ✅ الخلاصة :

مسؤولية النظام حقنا (الي بلغة Go) هي:

1. نوفّر Endpoint مثل `/register`
    
2. نعرف المفتاح السري للتحقق من التوكنات
    
3. نستخدم مكتبة JWT نتحقق ونقرأ منها البيانات
    
4. نتعامل مع قاعدة البيانات ونسجّل المستخدمين بناءً على التوكنات
    

**إحنا ما نصدر التوكنات بأنفسنا، إحنا فقط نستقبلها ونتعامل معها بذكاء 




المخطط للتدفق FLOWCHART

``` mermaid
flowchart TD
    A[النظام الخارجي يصدر التوكن JWT] -->|يوقع بالمفتاح السري| B[توكن JWT]
    B --> C[المستخدم يحمل التوكن]
    C --> D[يرسل طلب POST /api/v1/register مع التوكن]
    D --> E[السيرفر يستقبل الطلب]
    E --> F{هل التوقيع صحيح؟}
    F -- لا --> G[رفض الطلب 401 غير مصرح]
    F -- نعم --> H{هل التوكن منتهي؟}
    H -- نعم --> G
    H -- لا --> I[استخراج بيانات المستخدم\nالاسم، الإيميل، الدور]
    I --> J{هل المستخدم موجود؟}
    J -- نعم --> K[يرد: مستخدم مسجل مسبقاً]
    J -- لا --> L[إضافة المستخدم لقاعدة البيانات]
    K --> M[يرد: تم التسجيل بنجاح]
    L --> M

```

```mermaid

flowchart TD
    subgraph External Clients
        Dashboard[🖥️ Dashboard / نظام خارجي]
    end

    subgraph Central System
        API[🔌 Control API (gRPC)]
        Hub[🧠 Central Hub]
        Directory[(📚 دليل الوكلاء)]
    end

    subgraph Agents
        Agent1[🛰️ وكيل 1]
        Agent2[🛰️ وكيل 2]
        Agent3[🛰️ وكيل 3]
    end

    Dashboard -->|يطلب قائمة أوامر| API
    API --> Hub
    Hub --> Directory
    Directory --> Hub

    Hub -->|يمرر الطلب| Agent1
    Agent1 -->|يرجع النتيجة| Hub
    Hub --> API
    API --> Dashboard

    Agent1 -->|تسجيل ذاتي| Hub
    Agent2 -->|تسجيل ذاتي| Hub
    Agent3 -->|تسجيل ذاتي| Hub

```

